<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDA (Symbolic DA/TPSA): SymbDA::DAVector Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDA (Symbolic DA/TPSA)
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_symb_d_a_1_1_d_a_vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="struct_symb_d_a_1_1_d_a_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SymbDA::DAVector Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators.  
 <a href="struct_symb_d_a_1_1_d_a_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sda_8h_source.html">sda.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a716d79afef8fe79f54f727be418e6d80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a716d79afef8fe79f54f727be418e6d80">DAVector</a> ()</td></tr>
<tr class="separator:a716d79afef8fe79f54f727be418e6d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c6ffb4c5161294d0b6437c61112bcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a42c6ffb4c5161294d0b6437c61112bcd">DAVector</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a42c6ffb4c5161294d0b6437c61112bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c3344d362fbf3b7ec722e951c54d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a577c3344d362fbf3b7ec722e951c54d2">DAVector</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a577c3344d362fbf3b7ec722e951c54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d854d49bfa760191f8400f15c68bb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a16d854d49bfa760191f8400f15c68bb3">DAVector</a> (double x)</td></tr>
<tr class="separator:a16d854d49bfa760191f8400f15c68bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5507a5d7562d142fee6d438ce74e681"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#aa5507a5d7562d142fee6d438ce74e681">DAVector</a> (int i)</td></tr>
<tr class="separator:aa5507a5d7562d142fee6d438ce74e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33626bb4c837c9826b925ad0293dfa05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a33626bb4c837c9826b925ad0293dfa05">DAVector</a> (SymEngine::Expression s)</td></tr>
<tr class="separator:a33626bb4c837c9826b925ad0293dfa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2421f40329e818efcd26bb135a663580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a2421f40329e818efcd26bb135a663580">DAVector</a> (std::vector&lt; SymEngine::Expression &gt; &amp;v)</td></tr>
<tr class="separator:a2421f40329e818efcd26bb135a663580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c14e52997f7802a5f85a7c9c598d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#aa4c14e52997f7802a5f85a7c9c598d27">print</a> () const</td></tr>
<tr class="separator:aa4c14e52997f7802a5f85a7c9c598d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69472168ff994c954ce2f3c6183d24de"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a69472168ff994c954ce2f3c6183d24de">con</a> () const</td></tr>
<tr class="separator:a69472168ff994c954ce2f3c6183d24de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cce20a6d8d742fe2c1b3c64cd127ba"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a27cce20a6d8d742fe2c1b3c64cd127ba">length</a> () const</td></tr>
<tr class="memdesc:a27cce20a6d8d742fe2c1b3c64cd127ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the DA vector.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a27cce20a6d8d742fe2c1b3c64cd127ba">More...</a><br /></td></tr>
<tr class="separator:a27cce20a6d8d742fe2c1b3c64cd127ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2c72c537b35af495437802fcd4c34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5eb2c72c537b35af495437802fcd4c34">n_element</a> () const</td></tr>
<tr class="separator:a5eb2c72c537b35af495437802fcd4c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4e6f3af99c877de4f72a6c27e1a0a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a6f4e6f3af99c877de4f72a6c27e1a0a7">element</a> (unsigned int i, unsigned int *c, SymEngine::Expression &amp;elem) const</td></tr>
<tr class="memdesc:a6f4e6f3af99c877de4f72a6c27e1a0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a6f4e6f3af99c877de4f72a6c27e1a0a7">More...</a><br /></td></tr>
<tr class="separator:a6f4e6f3af99c877de4f72a6c27e1a0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4f83b082acf39f54ab33c5a2f48bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a3d4f83b082acf39f54ab33c5a2f48bc8">element</a> (unsigned int i, std::vector&lt; unsigned int &gt; &amp;c, SymEngine::Expression &amp;elem) const</td></tr>
<tr class="memdesc:a3d4f83b082acf39f54ab33c5a2f48bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of vector c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a3d4f83b082acf39f54ab33c5a2f48bc8">More...</a><br /></td></tr>
<tr class="separator:a3d4f83b082acf39f54ab33c5a2f48bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f80af3a9255f116b99df88511b0b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a42f80af3a9255f116b99df88511b0b96">derivative</a> (unsigned int i, unsigned int *c, SymEngine::Expression &amp;elem) const</td></tr>
<tr class="memdesc:a42f80af3a9255f116b99df88511b0b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific partial derivative. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!)  <a href="struct_symb_d_a_1_1_d_a_vector.html#a42f80af3a9255f116b99df88511b0b96">More...</a><br /></td></tr>
<tr class="separator:a42f80af3a9255f116b99df88511b0b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab3ebc477ce7f09a2b5947be79f5014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5ab3ebc477ce7f09a2b5947be79f5014">derivative</a> (unsigned int i, std::vector&lt; unsigned int &gt; &amp;c, SymEngine::Expression &amp;elem) const</td></tr>
<tr class="memdesc:a5ab3ebc477ce7f09a2b5947be79f5014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific partial derivative. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!)  <a href="struct_symb_d_a_1_1_d_a_vector.html#a5ab3ebc477ce7f09a2b5947be79f5014">More...</a><br /></td></tr>
<tr class="separator:a5ab3ebc477ce7f09a2b5947be79f5014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b48264e52335e6c6edeb9f4b8439c"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a422b48264e52335e6c6edeb9f4b8439c">element</a> (int i)</td></tr>
<tr class="memdesc:a422b48264e52335e6c6edeb9f4b8439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific element. Given the ordinal number of the element, return the value. The ordinal number starts from zero, following c++ tradition.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a422b48264e52335e6c6edeb9f4b8439c">More...</a><br /></td></tr>
<tr class="separator:a422b48264e52335e6c6edeb9f4b8439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf81848a75763a543b1088964cdecfb"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5bf81848a75763a543b1088964cdecfb">element</a> (std::vector&lt; int &gt; idx)</td></tr>
<tr class="memdesc:a5bf81848a75763a543b1088964cdecfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific element. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a5bf81848a75763a543b1088964cdecfb">More...</a><br /></td></tr>
<tr class="separator:a5bf81848a75763a543b1088964cdecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dd37f7a67013fb8355b719b54d28a9"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a81dd37f7a67013fb8355b719b54d28a9">derivative</a> (std::vector&lt; int &gt; idx)</td></tr>
<tr class="memdesc:a81dd37f7a67013fb8355b719b54d28a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific partial derivative. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!)  <a href="struct_symb_d_a_1_1_d_a_vector.html#a81dd37f7a67013fb8355b719b54d28a9">More...</a><br /></td></tr>
<tr class="separator:a81dd37f7a67013fb8355b719b54d28a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b247108d4f108cdb34e3da8e9ff14c2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a1b247108d4f108cdb34e3da8e9ff14c2">element_orders</a> (int i)</td></tr>
<tr class="memdesc:a1b247108d4f108cdb34e3da8e9ff14c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orders of the bases for the specific element in a DA vector.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a1b247108d4f108cdb34e3da8e9ff14c2">More...</a><br /></td></tr>
<tr class="separator:a1b247108d4f108cdb34e3da8e9ff14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60efa18ad4c50384601a1fedbd5827a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a60efa18ad4c50384601a1fedbd5827a5">simplify</a> ()</td></tr>
<tr class="memdesc:a60efa18ad4c50384601a1fedbd5827a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify each elements in the DA vector.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a60efa18ad4c50384601a1fedbd5827a5">More...</a><br /></td></tr>
<tr class="separator:a60efa18ad4c50384601a1fedbd5827a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfe9bb9c06084e95a31ef51ccacdd08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#acdfe9bb9c06084e95a31ef51ccacdd08">set_element</a> (int *c, SymEngine::Expression elem)</td></tr>
<tr class="memdesc:acdfe9bb9c06084e95a31ef51ccacdd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_symb_d_a_1_1_d_a_vector.html#acdfe9bb9c06084e95a31ef51ccacdd08">More...</a><br /></td></tr>
<tr class="separator:acdfe9bb9c06084e95a31ef51ccacdd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd68d8ab64f6a7e11936048ce9236e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a6bd68d8ab64f6a7e11936048ce9236e1">set_element</a> (std::vector&lt; int &gt; idx, SymEngine::Expression elem)</td></tr>
<tr class="memdesc:a6bd68d8ab64f6a7e11936048ce9236e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a6bd68d8ab64f6a7e11936048ce9236e1">More...</a><br /></td></tr>
<tr class="separator:a6bd68d8ab64f6a7e11936048ce9236e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906474290a2c090a98f7231f60b69a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a906474290a2c090a98f7231f60b69a3e">set_element</a> (int *c, double elem)</td></tr>
<tr class="memdesc:a906474290a2c090a98f7231f60b69a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a906474290a2c090a98f7231f60b69a3e">More...</a><br /></td></tr>
<tr class="separator:a906474290a2c090a98f7231f60b69a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7223f89208a74ec944b97734865cf846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a7223f89208a74ec944b97734865cf846">set_element</a> (std::vector&lt; int &gt; idx, double elem)</td></tr>
<tr class="memdesc:a7223f89208a74ec944b97734865cf846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a7223f89208a74ec944b97734865cf846">More...</a><br /></td></tr>
<tr class="separator:a7223f89208a74ec944b97734865cf846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d453e616e6727001a9bf08e0e41928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a41d453e616e6727001a9bf08e0e41928">set_element</a> (int i, SymEngine::Expression elem)</td></tr>
<tr class="memdesc:a41d453e616e6727001a9bf08e0e41928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a41d453e616e6727001a9bf08e0e41928">More...</a><br /></td></tr>
<tr class="separator:a41d453e616e6727001a9bf08e0e41928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639cbfeae006699857f106b8a5b2b76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a639cbfeae006699857f106b8a5b2b76b">reset</a> ()</td></tr>
<tr class="separator:a639cbfeae006699857f106b8a5b2b76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191f1727b15f59128647450a8086dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a9191f1727b15f59128647450a8086dcd">reset_const</a> (double x=0)</td></tr>
<tr class="memdesc:a9191f1727b15f59128647450a8086dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the value to the given number. Vector length is set to 1.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a9191f1727b15f59128647450a8086dcd">More...</a><br /></td></tr>
<tr class="separator:a9191f1727b15f59128647450a8086dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00a8d7fb77e94cbeb45e365dde3e079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#aa00a8d7fb77e94cbeb45e365dde3e079">reset_const</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:aa00a8d7fb77e94cbeb45e365dde3e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71a3d7f15d14381ba976bd9016587c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ac71a3d7f15d14381ba976bd9016587c5">clean</a> (const double <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ae95a6ee31f26592ee31ba88083e8231a">eps</a>)</td></tr>
<tr class="memdesc:ac71a3d7f15d14381ba976bd9016587c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the given eps.  <a href="struct_symb_d_a_1_1_d_a_vector.html#ac71a3d7f15d14381ba976bd9016587c5">More...</a><br /></td></tr>
<tr class="separator:ac71a3d7f15d14381ba976bd9016587c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f793f51f2f5779da3d7294099f6767b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5f793f51f2f5779da3d7294099f6767b">clean</a> ()</td></tr>
<tr class="memdesc:a5f793f51f2f5779da3d7294099f6767b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the global eps.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a5f793f51f2f5779da3d7294099f6767b">More...</a><br /></td></tr>
<tr class="separator:a5f793f51f2f5779da3d7294099f6767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88f8a2cfdcd8b6d29b4f7b96683819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#abd88f8a2cfdcd8b6d29b4f7b96683819">iszero</a> () const</td></tr>
<tr class="memdesc:abd88f8a2cfdcd8b6d29b4f7b96683819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the abs value of the coefficients in the <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the cut-off value.  <a href="struct_symb_d_a_1_1_d_a_vector.html#abd88f8a2cfdcd8b6d29b4f7b96683819">More...</a><br /></td></tr>
<tr class="separator:abd88f8a2cfdcd8b6d29b4f7b96683819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8591fa08ae9c8d188ba234aa2fbfa157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a8591fa08ae9c8d188ba234aa2fbfa157">iszero</a> (double <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ae95a6ee31f26592ee31ba88083e8231a">eps</a>) const</td></tr>
<tr class="memdesc:a8591fa08ae9c8d188ba234aa2fbfa157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the abs value of the coefficients in the <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the given value eps.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a8591fa08ae9c8d188ba234aa2fbfa157">More...</a><br /></td></tr>
<tr class="separator:a8591fa08ae9c8d188ba234aa2fbfa157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a20f63a17c992484fca53560c05299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a18a20f63a17c992484fca53560c05299">clear</a> ()</td></tr>
<tr class="separator:a18a20f63a17c992484fca53560c05299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bfa3ef26a7cdf8b308f4962e0c9869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a64bfa3ef26a7cdf8b308f4962e0c9869">eval</a> (SymEngine::map_basic_basic m)</td></tr>
<tr class="memdesc:a64bfa3ef26a7cdf8b308f4962e0c9869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an DA vector by submitting values to the symbols Replace all the symbols by numbers in a DA vector and calculate the values of all the elements.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a64bfa3ef26a7cdf8b308f4962e0c9869">More...</a><br /></td></tr>
<tr class="separator:a64bfa3ef26a7cdf8b308f4962e0c9869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ff7aae94e020fbbc264e05f614461a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a04ff7aae94e020fbbc264e05f614461a">eval_funs</a> (std::vector&lt; SymEngine::RCP&lt; const SymEngine::Basic &gt;&gt; vars, std::vector&lt; SymEngine::LambdaRealDoubleVisitor &gt; &amp;v)</td></tr>
<tr class="memdesc:a04ff7aae94e020fbbc264e05f614461a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the expressions into callable functions far all the elements.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a04ff7aae94e020fbbc264e05f614461a">More...</a><br /></td></tr>
<tr class="separator:a04ff7aae94e020fbbc264e05f614461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bce11bd7389cb9ab130e298528ef9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5bce11bd7389cb9ab130e298528ef9c2">eval_funs</a> (std::vector&lt; SymEngine::RCP&lt; const SymEngine::Basic &gt;&gt; vars, SymEngine::LambdaRealDoubleVisitor &amp;v)</td></tr>
<tr class="memdesc:a5bce11bd7389cb9ab130e298528ef9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the expressions into callable functions far all the elements.  <a href="struct_symb_d_a_1_1_d_a_vector.html#a5bce11bd7389cb9ab130e298528ef9c2">More...</a><br /></td></tr>
<tr class="separator:a5bce11bd7389cb9ab130e298528ef9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44fcc5f5e5c67c4d7b4a42a407189bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#aa44fcc5f5e5c67c4d7b4a42a407189bc">operator=</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:aa44fcc5f5e5c67c4d7b4a42a407189bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da016d47013c90c9202b9668ae58bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a42da016d47013c90c9202b9668ae58bf">operator=</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a42da016d47013c90c9202b9668ae58bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f03eac987f0ece2fd57573015d19358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a7f03eac987f0ece2fd57573015d19358">operator=</a> (double x)</td></tr>
<tr class="separator:a7f03eac987f0ece2fd57573015d19358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc1cef001797b3b4aad5f2052151774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#aadc1cef001797b3b4aad5f2052151774">operator=</a> (int x)</td></tr>
<tr class="separator:aadc1cef001797b3b4aad5f2052151774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4549cd3208a13d330b7bced63c3c657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ad4549cd3208a13d330b7bced63c3c657">operator=</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:ad4549cd3208a13d330b7bced63c3c657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aeebfad28eb2506dd24507f17bdd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a06aeebfad28eb2506dd24507f17bdd02">operator+=</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a06aeebfad28eb2506dd24507f17bdd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eefbae62c7ad01a97682f15815038b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a7eefbae62c7ad01a97682f15815038b6">operator+=</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#af6621d15c79745b9b20c970d44f2b1c5">da_vector_</a>)</td></tr>
<tr class="separator:a7eefbae62c7ad01a97682f15815038b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a97dde6ebdb32f5ca7f530d648648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a786a97dde6ebdb32f5ca7f530d648648">operator+=</a> (double x)</td></tr>
<tr class="separator:a786a97dde6ebdb32f5ca7f530d648648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d4408710acd84a763e587e794d8f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a83d4408710acd84a763e587e794d8f5d">operator+=</a> (int x)</td></tr>
<tr class="separator:a83d4408710acd84a763e587e794d8f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3379c2a070159166e604d6ba102d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a97c3379c2a070159166e604d6ba102d3">operator+=</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:a97c3379c2a070159166e604d6ba102d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cbe7d9afabfa05e7bd5c45fcc3fabf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ae8cbe7d9afabfa05e7bd5c45fcc3fabf">operator-=</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:ae8cbe7d9afabfa05e7bd5c45fcc3fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ae2aa71b20e2b66c3eb90173e4419d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a77ae2aa71b20e2b66c3eb90173e4419d">operator-=</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#af6621d15c79745b9b20c970d44f2b1c5">da_vector_</a>)</td></tr>
<tr class="separator:a77ae2aa71b20e2b66c3eb90173e4419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bd9289824110ad5c5b9846706e67c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a45bd9289824110ad5c5b9846706e67c3">operator-=</a> (double x)</td></tr>
<tr class="separator:a45bd9289824110ad5c5b9846706e67c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913dd55d22a716a914bf27b8a24f2c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a913dd55d22a716a914bf27b8a24f2c34">operator-=</a> (int x)</td></tr>
<tr class="separator:a913dd55d22a716a914bf27b8a24f2c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaa32653b2fe44b261ebcf788f631cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#abfaa32653b2fe44b261ebcf788f631cc">operator-=</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:abfaa32653b2fe44b261ebcf788f631cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ee3043a201d0d2c189148499604a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a63ee3043a201d0d2c189148499604a31">operator*=</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a63ee3043a201d0d2c189148499604a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c29a500b41660d6a8a685d663ed284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ac4c29a500b41660d6a8a685d663ed284">operator*=</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:ac4c29a500b41660d6a8a685d663ed284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53615a116e1565d1ad24077842f3044a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a53615a116e1565d1ad24077842f3044a">operator*=</a> (double x)</td></tr>
<tr class="separator:a53615a116e1565d1ad24077842f3044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed06161871eec0304c99b917a5872c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a9ed06161871eec0304c99b917a5872c4">operator*=</a> (int x)</td></tr>
<tr class="separator:a9ed06161871eec0304c99b917a5872c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122c8f1f7b665c28fd5dbfb9ac689840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a122c8f1f7b665c28fd5dbfb9ac689840">operator*=</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:a122c8f1f7b665c28fd5dbfb9ac689840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c1aec3c3d7b2b2b7c5a9809aab57a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a68c1aec3c3d7b2b2b7c5a9809aab57a4">operator/=</a> (const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a68c1aec3c3d7b2b2b7c5a9809aab57a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015278ada0f06902320cc7382e880bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a015278ada0f06902320cc7382e880bab">operator/=</a> (<a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a015278ada0f06902320cc7382e880bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdc52c9b8af1307d84d77bddeab0e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a1cdc52c9b8af1307d84d77bddeab0e2c">operator/=</a> (double x)</td></tr>
<tr class="separator:a1cdc52c9b8af1307d84d77bddeab0e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f68dadbab29ef6c50b0735416cd471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a85f68dadbab29ef6c50b0735416cd471">operator/=</a> (int x)</td></tr>
<tr class="separator:a85f68dadbab29ef6c50b0735416cd471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d745e4b42a69c9d4e13b8ddad73f261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a9d745e4b42a69c9d4e13b8ddad73f261">operator/=</a> (SymEngine::Expression x)</td></tr>
<tr class="separator:a9d745e4b42a69c9d4e13b8ddad73f261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc4892ff243c3afb20ef6776d188030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a5fc4892ff243c3afb20ef6776d188030">~DAVector</a> ()</td></tr>
<tr class="separator:a5fc4892ff243c3afb20ef6776d188030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac9b362e41cf58c02f881172bd38a4708"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ac9b362e41cf58c02f881172bd38a4708">dim</a> ()</td></tr>
<tr class="separator:ac9b362e41cf58c02f881172bd38a4708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dfa4307e005592c788e3d8e5eb1706"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#a31dfa4307e005592c788e3d8e5eb1706">order</a> ()</td></tr>
<tr class="separator:a31dfa4307e005592c788e3d8e5eb1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e857db5dbafeb057e106dd86595beb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#af6e857db5dbafeb057e106dd86595beb">full_length</a> ()</td></tr>
<tr class="separator:af6e857db5dbafeb057e106dd86595beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af6621d15c79745b9b20c970d44f2b1c5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#af6621d15c79745b9b20c970d44f2b1c5">da_vector_</a></td></tr>
<tr class="separator:af6621d15c79745b9b20c970d44f2b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae95a6ee31f26592ee31ba88083e8231a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html#ae95a6ee31f26592ee31ba88083e8231a">eps</a> = 1e-16</td></tr>
<tr class="separator:ae95a6ee31f26592ee31ba88083e8231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a716d79afef8fe79f54f727be418e6d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d79afef8fe79f54f727be418e6d80">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42c6ffb4c5161294d0b6437c61112bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c6ffb4c5161294d0b6437c61112bcd">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a577c3344d362fbf3b7ec722e951c54d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577c3344d362fbf3b7ec722e951c54d2">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16d854d49bfa760191f8400f15c68bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d854d49bfa760191f8400f15c68bb3">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5507a5d7562d142fee6d438ce74e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5507a5d7562d142fee6d438ce74e681">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33626bb4c837c9826b925ad0293dfa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33626bb4c837c9826b925ad0293dfa05">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2421f40329e818efcd26bb135a663580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2421f40329e818efcd26bb135a663580">&#9670;&nbsp;</a></span>DAVector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::DAVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymEngine::Expression &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fc4892ff243c3afb20ef6776d188030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc4892ff243c3afb20ef6776d188030">&#9670;&nbsp;</a></span>~DAVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbDA::DAVector::~DAVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5f793f51f2f5779da3d7294099f6767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f793f51f2f5779da3d7294099f6767b">&#9670;&nbsp;</a></span>clean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::clean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the global eps. </p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="ac71a3d7f15d14381ba976bd9016587c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71a3d7f15d14381ba976bd9016587c5">&#9670;&nbsp;</a></span>clean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::clean </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the given eps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>threshold for zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a18a20f63a17c992484fca53560c05299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a20f63a17c992484fca53560c05299">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69472168ff994c954ce2f3c6183d24de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69472168ff994c954ce2f3c6183d24de">&#9670;&nbsp;</a></span>con()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymEngine::Expression SymbDA::DAVector::con </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the constant element of a DA vector. </p>

</div>
</div>
<a id="a81dd37f7a67013fb8355b719b54d28a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dd37f7a67013fb8355b719b54d28a9">&#9670;&nbsp;</a></span>derivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymEngine::Expression SymbDA::DAVector::derivative </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific partial derivative. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the partial derivative. </dd></dl>

</div>
</div>
<a id="a5ab3ebc477ce7f09a2b5947be79f5014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab3ebc477ce7f09a2b5947be79f5014">&#9670;&nbsp;</a></span>derivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::derivative </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific partial derivative. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the partial derivative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a42f80af3a9255f116b99df88511b0b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f80af3a9255f116b99df88511b0b96">&#9670;&nbsp;</a></span>derivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::derivative </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific partial derivative. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. The parital derivative is the element multiplied by (nx!)*(ny!)*(nz!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the partial derivative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac9b362e41cf58c02f881172bd38a4708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b362e41cf58c02f881172bd38a4708">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbDA::DAVector::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the DA base number. </p>

</div>
</div>
<a id="a422b48264e52335e6c6edeb9f4b8439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b48264e52335e6c6edeb9f4b8439c">&#9670;&nbsp;</a></span>element() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymEngine::Expression SymbDA::DAVector::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific element. Given the ordinal number of the element, return the value. The ordinal number starts from zero, following c++ tradition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element. </dd></dl>

</div>
</div>
<a id="a5bf81848a75763a543b1088964cdecfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf81848a75763a543b1088964cdecfb">&#9670;&nbsp;</a></span>element() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymEngine::Expression SymbDA::DAVector::element </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific element. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element. </dd></dl>

</div>
</div>
<a id="a3d4f83b082acf39f54ab33c5a2f48bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4f83b082acf39f54ab33c5a2f48bc8">&#9670;&nbsp;</a></span>element() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::element </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of vector c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a6f4e6f3af99c877de4f72a6c27e1a0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4e6f3af99c877de4f72a6c27e1a0a7">&#9670;&nbsp;</a></span>element() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::element </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1b247108d4f108cdb34e3da8e9ff14c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b247108d4f108cdb34e3da8e9ff14c2">&#9670;&nbsp;</a></span>element_orders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; &amp; SymbDA::DAVector::element_orders </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the orders of the bases for the specific element in a DA vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The orders of the bases in an int vector. </dd></dl>

</div>
</div>
<a id="a64bfa3ef26a7cdf8b308f4962e0c9869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bfa3ef26a7cdf8b308f4962e0c9869">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::eval </td>
          <td>(</td>
          <td class="paramtype">SymEngine::map_basic_basic&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an DA vector by submitting values to the symbols Replace all the symbols by numbers in a DA vector and calculate the values of all the elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The map from symbols to values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a04ff7aae94e020fbbc264e05f614461a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ff7aae94e020fbbc264e05f614461a">&#9670;&nbsp;</a></span>eval_funs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::eval_funs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymEngine::RCP&lt; const SymEngine::Basic &gt;&gt;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; SymEngine::LambdaRealDoubleVisitor &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the expressions into callable functions far all the elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>All the variables/symbols in the DA vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>A vector of the callable functions. Each element is a callable function for the respective element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a5bce11bd7389cb9ab130e298528ef9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bce11bd7389cb9ab130e298528ef9c2">&#9670;&nbsp;</a></span>eval_funs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::eval_funs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; SymEngine::RCP&lt; const SymEngine::Basic &gt;&gt;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::LambdaRealDoubleVisitor &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the expressions into callable functions far all the elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>All the variables/symbols in the DA vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>A callable function that saves all the functions from the elements in the DA vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="af6e857db5dbafeb057e106dd86595beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e857db5dbafeb057e106dd86595beb">&#9670;&nbsp;</a></span>full_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbDA::DAVector::full_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd88f8a2cfdcd8b6d29b4f7b96683819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd88f8a2cfdcd8b6d29b4f7b96683819">&#9670;&nbsp;</a></span>iszero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbDA::DAVector::iszero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all the abs value of the coefficients in the <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the cut-off value. </p>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="a8591fa08ae9c8d188ba234aa2fbfa157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8591fa08ae9c8d188ba234aa2fbfa157">&#9670;&nbsp;</a></span>iszero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SymbDA::DAVector::iszero </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all the abs value of the coefficients in the <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the given value eps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>The value to compare with the abs value of the coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="a27cce20a6d8d742fe2c1b3c64cd127ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cce20a6d8d742fe2c1b3c64cd127ba">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SymbDA::DAVector::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of the DA vector. </p>

</div>
</div>
<a id="a5eb2c72c537b35af495437802fcd4c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb2c72c537b35af495437802fcd4c34">&#9670;&nbsp;</a></span>n_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SymbDA::DAVector::n_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of non-zero element a DA vector. </p>

</div>
</div>
<a id="a63ee3043a201d0d2c189148499604a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ee3043a201d0d2c189148499604a31">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4c29a500b41660d6a8a685d663ed284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c29a500b41660d6a8a685d663ed284">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53615a116e1565d1ad24077842f3044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53615a116e1565d1ad24077842f3044a">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed06161871eec0304c99b917a5872c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed06161871eec0304c99b917a5872c4">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a122c8f1f7b665c28fd5dbfb9ac689840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122c8f1f7b665c28fd5dbfb9ac689840">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06aeebfad28eb2506dd24507f17bdd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06aeebfad28eb2506dd24507f17bdd02">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eefbae62c7ad01a97682f15815038b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eefbae62c7ad01a97682f15815038b6">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a786a97dde6ebdb32f5ca7f530d648648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786a97dde6ebdb32f5ca7f530d648648">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83d4408710acd84a763e587e794d8f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d4408710acd84a763e587e794d8f5d">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97c3379c2a070159166e604d6ba102d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c3379c2a070159166e604d6ba102d3">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8cbe7d9afabfa05e7bd5c45fcc3fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cbe7d9afabfa05e7bd5c45fcc3fabf">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ae2aa71b20e2b66c3eb90173e4419d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ae2aa71b20e2b66c3eb90173e4419d">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45bd9289824110ad5c5b9846706e67c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bd9289824110ad5c5b9846706e67c3">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a913dd55d22a716a914bf27b8a24f2c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913dd55d22a716a914bf27b8a24f2c34">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfaa32653b2fe44b261ebcf788f631cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfaa32653b2fe44b261ebcf788f631cc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68c1aec3c3d7b2b2b7c5a9809aab57a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c1aec3c3d7b2b2b7c5a9809aab57a4">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a015278ada0f06902320cc7382e880bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015278ada0f06902320cc7382e880bab">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cdc52c9b8af1307d84d77bddeab0e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdc52c9b8af1307d84d77bddeab0e2c">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85f68dadbab29ef6c50b0735416cd471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f68dadbab29ef6c50b0735416cd471">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d745e4b42a69c9d4e13b8ddad73f261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d745e4b42a69c9d4e13b8ddad73f261">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa44fcc5f5e5c67c4d7b4a42a407189bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44fcc5f5e5c67c4d7b4a42a407189bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42da016d47013c90c9202b9668ae58bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42da016d47013c90c9202b9668ae58bf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f03eac987f0ece2fd57573015d19358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f03eac987f0ece2fd57573015d19358">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadc1cef001797b3b4aad5f2052151774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc1cef001797b3b4aad5f2052151774">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator= </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4549cd3208a13d330b7bced63c3c657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4549cd3208a13d330b7bced63c3c657">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a> &amp; SymbDA::DAVector::operator= </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31dfa4307e005592c788e3d8e5eb1706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dfa4307e005592c788e3d8e5eb1706">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SymbDA::DAVector::order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4c14e52997f7802a5f85a7c9c598d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c14e52997f7802a5f85a7c9c598d27">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print out a DA vector. </p>

</div>
</div>
<a id="a639cbfeae006699857f106b8a5b2b76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639cbfeae006699857f106b8a5b2b76b">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all element to zero, vector length unchanged. </p>

</div>
</div>
<a id="a9191f1727b15f59128647450a8086dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9191f1727b15f59128647450a8086dcd">&#9670;&nbsp;</a></span>reset_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::reset_const </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the value to the given number. Vector length is set to 1. </p>

</div>
</div>
<a id="aa00a8d7fb77e94cbeb45e365dde3e079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00a8d7fb77e94cbeb45e365dde3e079">&#9670;&nbsp;</a></span>reset_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::reset_const </td>
          <td>(</td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a906474290a2c090a98f7231f60b69a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906474290a2c090a98f7231f60b69a3e">&#9670;&nbsp;</a></span>set_element() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="acdfe9bb9c06084e95a31ef51ccacdd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfe9bb9c06084e95a31ef51ccacdd08">&#9670;&nbsp;</a></span>set_element() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The expression of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a41d453e616e6727001a9bf08e0e41928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d453e616e6727001a9bf08e0e41928">&#9670;&nbsp;</a></span>set_element() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a7223f89208a74ec944b97734865cf846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7223f89208a74ec944b97734865cf846">&#9670;&nbsp;</a></span>set_element() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a6bd68d8ab64f6a7e11936048ce9236e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd68d8ab64f6a7e11936048ce9236e1">&#9670;&nbsp;</a></span>set_element() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymEngine::Expression&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The expression of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a60efa18ad4c50384601a1fedbd5827a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60efa18ad4c50384601a1fedbd5827a5">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SymbDA::DAVector::simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify each elements in the DA vector. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af6621d15c79745b9b20c970d44f2b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6621d15c79745b9b20c970d44f2b1c5">&#9670;&nbsp;</a></span>da_vector_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SymbDA::DAVector::da_vector_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae95a6ee31f26592ee31ba88083e8231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95a6ee31f26592ee31ba88083e8231a">&#9670;&nbsp;</a></span>eps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SymbDA::DAVector::eps = 1e-16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global threshold of the abs value of <a class="el" href="struct_symb_d_a_1_1_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> coefficients. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/<a class="el" href="sda_8h_source.html">sda.h</a></li>
<li>src/<a class="el" href="sda_8cc.html">sda.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_symb_d_a.html">SymbDA</a></li><li class="navelem"><a class="el" href="struct_symb_d_a_1_1_d_a_vector.html">DAVector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
